// GENERATED CODE - DO NOT MODIFY BY HAND
// This code was generated by ObjectBox. To update it run the generator again:
// With a Flutter package, run `flutter pub run build_runner build`.
// With a Dart package, run `dart run build_runner build`.
// See also https://docs.objectbox.io/getting-started#generate-objectbox-code

// ignore_for_file: camel_case_types

import 'dart:typed_data';

import 'package:flat_buffers/flat_buffers.dart' as fb;
import 'package:objectbox/internal.dart'; // generated code can access "internal" functionality
import 'package:objectbox/objectbox.dart';
import 'package:objectbox_flutter_libs/objectbox_flutter_libs.dart';

import 'app/core/models/app_models/permission_model.dart';
import 'app/core/models/app_models/region_model.dart';
import 'app/core/models/report_models/priority_model.dart';
import 'app/core/models/report_models/report_log_model.dart';
import 'app/core/models/report_models/report_model.dart';
import 'app/core/models/report_models/result_model.dart';
import 'app/core/models/report_models/short_user_model.dart';
import 'app/core/models/report_models/type_model.dart';
import 'app/core/models/user_models/user_model.dart';

export 'package:objectbox/objectbox.dart'; // so that callers only have to import this file

final _entities = <ModelEntity>[
  ModelEntity(
      id: const IdUid(1, 2994457994545753558),
      name: 'PermissionModel',
      lastPropertyId: const IdUid(2, 1414284754385485347),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 6499920911224648678),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 1414284754385485347),
            name: 'name',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[
        ModelBacklink(
            name: 'users', srcEntity: 'User', srcField: 'permissionRelation')
      ]),
  ModelEntity(
      id: const IdUid(2, 8496803727494426002),
      name: 'PriorityModel',
      lastPropertyId: const IdUid(2, 6556557771628573014),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 2154692202029051597),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 6556557771628573014),
            name: 'color',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[
        ModelBacklink(
            name: 'reports',
            srcEntity: 'Report',
            srcField: 'priorityModelRelation')
      ]),
  ModelEntity(
      id: const IdUid(3, 1019516131378027000),
      name: 'RegionModel',
      lastPropertyId: const IdUid(2, 4254657998565745233),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 7450053858525927878),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 4254657998565745233),
            name: 'name',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[
        ModelRelation(
            id: const IdUid(1, 9167704669891175069),
            name: 'users',
            targetId: const IdUid(9, 9135403782203839041))
      ],
      backlinks: <ModelBacklink>[
        ModelBacklink(
            name: 'reports',
            srcEntity: 'Report',
            srcField: 'regionModelRelation')
      ]),
  ModelEntity(
      id: const IdUid(4, 595112006845326204),
      name: 'Report',
      lastPropertyId: const IdUid(17, 1407756635787330730),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 4241001368971583988),
            name: 'patientIsCame',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(2, 829412522034097111),
            name: 'priorityModelRelationId',
            type: 11,
            flags: 520,
            indexId: const IdUid(1, 5466277017797789089),
            relationTarget: 'PriorityModel'),
        ModelProperty(
            id: const IdUid(3, 1049089858006097284),
            name: 'regionModelRelationId',
            type: 11,
            flags: 520,
            indexId: const IdUid(2, 965612781998706209),
            relationTarget: 'RegionModel'),
        ModelProperty(
            id: const IdUid(4, 8160921509076335012),
            name: 'typeModelRelationId',
            type: 11,
            flags: 520,
            indexId: const IdUid(3, 1809560712544719810),
            relationTarget: 'TypeModel'),
        ModelProperty(
            id: const IdUid(5, 182153228176191165),
            name: 'shortUserRelationReportId',
            type: 11,
            flags: 520,
            indexId: const IdUid(4, 6620524534748634197),
            relationTarget: 'ShortUser'),
        ModelProperty(
            id: const IdUid(6, 7912303071560089152),
            name: 'userIsReceived',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(7, 5552720909565374868),
            name: 'checkDate',
            type: 10,
            flags: 0),
        ModelProperty(
            id: const IdUid(8, 8400523673403593782),
            name: 'createdAt',
            type: 10,
            flags: 0),
        ModelProperty(
            id: const IdUid(9, 5968291683216944336),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(10, 3358910938597995099),
            name: 'name',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(11, 940570414270209786),
            name: 'phone',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(12, 4936703735650626693),
            name: 'optionalPhone',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(13, 5729291953655614343),
            name: 'details',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(14, 5199167681549019112),
            name: 'isSelected',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(15, 4548173459415444063),
            name: 'updatedAt',
            type: 10,
            flags: 0),
        ModelProperty(
            id: const IdUid(16, 6724010207465158724),
            name: 'visitDate',
            type: 10,
            flags: 0),
        ModelProperty(
            id: const IdUid(17, 1407756635787330730),
            name: 'addressDetails',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(5, 6479655532023327265),
      name: 'ReportLog',
      lastPropertyId: const IdUid(8, 4633944018911784597),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 8745602284933600612),
            name: 'resultModelRelationId',
            type: 11,
            flags: 520,
            indexId: const IdUid(5, 2011934489378504641),
            relationTarget: 'ResultModel'),
        ModelProperty(
            id: const IdUid(2, 9111124377806267693),
            name: 'shortUserRelationReportLogId',
            type: 11,
            flags: 520,
            indexId: const IdUid(6, 3514479251279882579),
            relationTarget: 'ShortUser'),
        ModelProperty(
            id: const IdUid(3, 6586202911528136832),
            name: 'reportId',
            type: 11,
            flags: 520,
            indexId: const IdUid(7, 1043414119408320639),
            relationTarget: 'Report'),
        ModelProperty(
            id: const IdUid(4, 8152704043874684438),
            name: 'date',
            type: 10,
            flags: 0),
        ModelProperty(
            id: const IdUid(5, 2967346774286832961),
            name: 'details',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(6, 3200940552800601279),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(7, 3189288135784188251),
            name: 'isSelected',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(8, 4633944018911784597),
            name: 'note',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(6, 8011624328720211922),
      name: 'ResultModel',
      lastPropertyId: const IdUid(3, 8443467854805347863),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 5481052994281033104),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 3200604839490765602),
            name: 'name',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 8443467854805347863),
            name: 'type',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[
        ModelBacklink(
            name: 'reportModels',
            srcEntity: 'ReportLog',
            srcField: 'resultModelRelation')
      ]),
  ModelEntity(
      id: const IdUid(7, 7881287263227840421),
      name: 'ShortUser',
      lastPropertyId: const IdUid(2, 2632909242469950872),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 918866242992283968),
            name: 'name',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(2, 2632909242469950872),
            name: 'id',
            type: 6,
            flags: 129)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[
        ModelBacklink(
            name: 'reportLogs',
            srcEntity: 'ReportLog',
            srcField: 'shortUserRelationReportLog'),
        ModelBacklink(
            name: 'reports',
            srcEntity: 'Report',
            srcField: 'shortUserRelationReport')
      ]),
  ModelEntity(
      id: const IdUid(8, 3383540060732898863),
      name: 'TypeModel',
      lastPropertyId: const IdUid(2, 617852753477642288),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 7332240438144974392),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 617852753477642288),
            name: 'name',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[
        ModelBacklink(
            name: 'reports', srcEntity: 'Report', srcField: 'typeModelRelation')
      ]),
  ModelEntity(
      id: const IdUid(9, 9135403782203839041),
      name: 'User',
      lastPropertyId: const IdUid(9, 6753055627518416501),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 6003568993872002370),
            name: 'imageUrl',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(2, 2298436244963842102),
            name: 'name',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 3965518709920705838),
            name: 'phone',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 8927162467927511783),
            name: 'refreshToken',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(5, 7694145771921983392),
            name: 'isOtherUser',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(6, 7957297616562038535),
            name: 'accessToken',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(7, 170234494749866358),
            name: 'accessTokenExpiryDate',
            type: 10,
            flags: 0),
        ModelProperty(
            id: const IdUid(8, 7829337140650230820),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(9, 6753055627518416501),
            name: 'permissionRelationId',
            type: 11,
            flags: 520,
            indexId: const IdUid(8, 8552284714232082132),
            relationTarget: 'PermissionModel')
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[])
];

/// Open an ObjectBox store with the model declared in this file.
Future<Store> openStore(
        {String? directory,
        int? maxDBSizeInKB,
        int? fileMode,
        int? maxReaders,
        bool queriesCaseSensitiveDefault = true,
        String? macosApplicationGroup}) async =>
    Store(getObjectBoxModel(),
        directory: directory ?? (await defaultStoreDirectory()).path,
        maxDBSizeInKB: maxDBSizeInKB,
        fileMode: fileMode,
        maxReaders: maxReaders,
        queriesCaseSensitiveDefault: queriesCaseSensitiveDefault,
        macosApplicationGroup: macosApplicationGroup);

/// ObjectBox model definition, pass it to [Store] - Store(getObjectBoxModel())
ModelDefinition getObjectBoxModel() {
  final model = ModelInfo(
      entities: _entities,
      lastEntityId: const IdUid(9, 9135403782203839041),
      lastIndexId: const IdUid(8, 8552284714232082132),
      lastRelationId: const IdUid(1, 9167704669891175069),
      lastSequenceId: const IdUid(0, 0),
      retiredEntityUids: const [],
      retiredIndexUids: const [],
      retiredPropertyUids: const [],
      retiredRelationUids: const [],
      modelVersion: 5,
      modelVersionParserMinimum: 5,
      version: 1);

  final bindings = <Type, EntityDefinition>{
    PermissionModel: EntityDefinition<PermissionModel>(
        model: _entities[0],
        toOneRelations: (PermissionModel object) => [],
        toManyRelations: (PermissionModel object) => {
              RelInfo<User>.toOneBacklink(9, object.id,
                      (User srcObject) => srcObject.permissionRelation):
                  object.users
            },
        getId: (PermissionModel object) => object.id,
        setId: (PermissionModel object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field PermissionModel.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (PermissionModel object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          fbb.startTable(3);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, nameOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = PermissionModel(
              id: const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0),
              name: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 6, ''));
          InternalToManyAccess.setRelInfo(
              object.users,
              store,
              RelInfo<User>.toOneBacklink(9, object.id,
                  (User srcObject) => srcObject.permissionRelation),
              store.box<PermissionModel>());
          return object;
        }),
    PriorityModel: EntityDefinition<PriorityModel>(
        model: _entities[1],
        toOneRelations: (PriorityModel object) => [],
        toManyRelations: (PriorityModel object) => {
              RelInfo<Report>.toOneBacklink(2, object.id,
                      (Report srcObject) => srcObject.priorityModelRelation):
                  object.reports
            },
        getId: (PriorityModel object) => object.id,
        setId: (PriorityModel object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field PriorityModel.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (PriorityModel object, fb.Builder fbb) {
          final colorOffset = fbb.writeString(object.color);
          fbb.startTable(3);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, colorOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = PriorityModel(
              id: const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0),
              color: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 6, ''));
          InternalToManyAccess.setRelInfo(
              object.reports,
              store,
              RelInfo<Report>.toOneBacklink(2, object.id,
                  (Report srcObject) => srcObject.priorityModelRelation),
              store.box<PriorityModel>());
          return object;
        }),
    RegionModel: EntityDefinition<RegionModel>(
        model: _entities[2],
        toOneRelations: (RegionModel object) => [],
        toManyRelations: (RegionModel object) => {
              RelInfo<RegionModel>.toMany(1, object.id): object.users,
              RelInfo<Report>.toOneBacklink(3, object.id,
                      (Report srcObject) => srcObject.regionModelRelation):
                  object.reports
            },
        getId: (RegionModel object) => object.id,
        setId: (RegionModel object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field RegionModel.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (RegionModel object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          fbb.startTable(3);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, nameOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = RegionModel(
              id: const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0),
              name: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 6, ''));
          InternalToManyAccess.setRelInfo(
              object.users,
              store,
              RelInfo<RegionModel>.toMany(1, object.id),
              store.box<RegionModel>());
          InternalToManyAccess.setRelInfo(
              object.reports,
              store,
              RelInfo<Report>.toOneBacklink(3, object.id,
                  (Report srcObject) => srcObject.regionModelRelation),
              store.box<RegionModel>());
          return object;
        }),
    Report: EntityDefinition<Report>(
        model: _entities[3],
        toOneRelations: (Report object) => [
              object.priorityModelRelation,
              object.regionModelRelation,
              object.typeModelRelation,
              object.shortUserRelationReport
            ],
        toManyRelations: (Report object) => {},
        getId: (Report object) => object.id,
        setId: (Report object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field Report.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (Report object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          final phoneOffset = fbb.writeString(object.phone);
          final optionalPhoneOffset = fbb.writeString(object.optionalPhone);
          final detailsOffset = fbb.writeString(object.details);
          final addressDetailsOffset = object.addressDetails == null
              ? null
              : fbb.writeString(object.addressDetails!);
          fbb.startTable(18);
          fbb.addBool(0, object.patientIsCame);
          fbb.addInt64(1, object.priorityModelRelation.targetId);
          fbb.addInt64(2, object.regionModelRelation.targetId);
          fbb.addInt64(3, object.typeModelRelation.targetId);
          fbb.addInt64(4, object.shortUserRelationReport.targetId);
          fbb.addBool(5, object.userIsReceived);
          fbb.addInt64(6, object.checkDate?.millisecondsSinceEpoch);
          fbb.addInt64(7, object.createdAt.millisecondsSinceEpoch);
          fbb.addInt64(8, object.id);
          fbb.addOffset(9, nameOffset);
          fbb.addOffset(10, phoneOffset);
          fbb.addOffset(11, optionalPhoneOffset);
          fbb.addOffset(12, detailsOffset);
          fbb.addBool(13, object.isSelected);
          fbb.addInt64(14, object.updatedAt?.millisecondsSinceEpoch);
          fbb.addInt64(15, object.visitDate?.millisecondsSinceEpoch);
          fbb.addOffset(16, addressDetailsOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final checkDateValue =
              const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 16);
          final updatedAtValue =
              const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 32);
          final visitDateValue =
              const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 34);
          final object = Report(
              id: const fb.Int64Reader().vTableGet(buffer, rootOffset, 20, 0),
              name: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 22, ''),
              phone: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 24, ''),
              checkDate: checkDateValue == null
                  ? null
                  : DateTime.fromMillisecondsSinceEpoch(checkDateValue),
              visitDate: visitDateValue == null
                  ? null
                  : DateTime.fromMillisecondsSinceEpoch(visitDateValue),
              userIsReceived: const fb.BoolReader()
                  .vTableGet(buffer, rootOffset, 14, false),
              patientIsCame:
                  const fb.BoolReader().vTableGet(buffer, rootOffset, 4, false),
              createdAt: DateTime.fromMillisecondsSinceEpoch(
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 18, 0)),
              updatedAt: updatedAtValue == null
                  ? null
                  : DateTime.fromMillisecondsSinceEpoch(updatedAtValue),
              optionalPhone: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 26, ''),
              details: const fb.StringReader(asciiOptimization: true).vTableGet(buffer, rootOffset, 28, ''),
              addressDetails: const fb.StringReader(asciiOptimization: true).vTableGetNullable(buffer, rootOffset, 36))
            ..isSelected = const fb.BoolReader().vTableGet(buffer, rootOffset, 30, false);
          object.priorityModelRelation.targetId =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 6, 0);
          object.priorityModelRelation.attach(store);
          object.regionModelRelation.targetId =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 8, 0);
          object.regionModelRelation.attach(store);
          object.typeModelRelation.targetId =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 10, 0);
          object.typeModelRelation.attach(store);
          object.shortUserRelationReport.targetId =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 12, 0);
          object.shortUserRelationReport.attach(store);
          return object;
        }),
    ReportLog: EntityDefinition<ReportLog>(
        model: _entities[4],
        toOneRelations: (ReportLog object) => [
              object.resultModelRelation,
              object.shortUserRelationReportLog,
              object.report
            ],
        toManyRelations: (ReportLog object) => {},
        getId: (ReportLog object) => object.id,
        setId: (ReportLog object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field ReportLog.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (ReportLog object, fb.Builder fbb) {
          final detailsOffset = fbb.writeString(object.details);
          final noteOffset = fbb.writeString(object.note);
          fbb.startTable(9);
          fbb.addInt64(0, object.resultModelRelation.targetId);
          fbb.addInt64(1, object.shortUserRelationReportLog.targetId);
          fbb.addInt64(2, object.report.targetId);
          fbb.addInt64(3, object.date.millisecondsSinceEpoch);
          fbb.addOffset(4, detailsOffset);
          fbb.addInt64(5, object.id);
          fbb.addBool(6, object.isSelected);
          fbb.addOffset(7, noteOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = ReportLog(
              id: const fb.Int64Reader().vTableGet(buffer, rootOffset, 14, 0),
              date: DateTime.fromMillisecondsSinceEpoch(
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 10, 0)),
              details: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 12, ''),
              note: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 18, ''))
            ..isSelected =
                const fb.BoolReader().vTableGet(buffer, rootOffset, 16, false);
          object.resultModelRelation.targetId =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          object.resultModelRelation.attach(store);
          object.shortUserRelationReportLog.targetId =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 6, 0);
          object.shortUserRelationReportLog.attach(store);
          object.report.targetId =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 8, 0);
          object.report.attach(store);
          return object;
        }),
    ResultModel: EntityDefinition<ResultModel>(
        model: _entities[5],
        toOneRelations: (ResultModel object) => [],
        toManyRelations: (ResultModel object) => {
              RelInfo<ReportLog>.toOneBacklink(1, object.id,
                      (ReportLog srcObject) => srcObject.resultModelRelation):
                  object.reportModels
            },
        getId: (ResultModel object) => object.id,
        setId: (ResultModel object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field ResultModel.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (ResultModel object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          final typeOffset = fbb.writeString(object.type);
          fbb.startTable(4);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, nameOffset);
          fbb.addOffset(2, typeOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = ResultModel(
              id: const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0),
              name: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 6, ''),
              type: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 8, ''));
          InternalToManyAccess.setRelInfo(
              object.reportModels,
              store,
              RelInfo<ReportLog>.toOneBacklink(1, object.id,
                  (ReportLog srcObject) => srcObject.resultModelRelation),
              store.box<ResultModel>());
          return object;
        }),
    ShortUser: EntityDefinition<ShortUser>(
        model: _entities[6],
        toOneRelations: (ShortUser object) => [],
        toManyRelations: (ShortUser object) => {
              RelInfo<ReportLog>.toOneBacklink(
                  2,
                  object.id,
                  (ReportLog srcObject) =>
                      srcObject.shortUserRelationReportLog): object.reportLogs,
              RelInfo<Report>.toOneBacklink(5, object.id,
                      (Report srcObject) => srcObject.shortUserRelationReport):
                  object.reports
            },
        getId: (ShortUser object) => object.id,
        setId: (ShortUser object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field ShortUser.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (ShortUser object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          fbb.startTable(3);
          fbb.addOffset(0, nameOffset);
          fbb.addInt64(1, object.id);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = ShortUser(
              id: const fb.Int64Reader().vTableGet(buffer, rootOffset, 6, 0),
              name: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 4, ''));
          InternalToManyAccess.setRelInfo(
              object.reportLogs,
              store,
              RelInfo<ReportLog>.toOneBacklink(
                  2,
                  object.id,
                  (ReportLog srcObject) =>
                      srcObject.shortUserRelationReportLog),
              store.box<ShortUser>());
          InternalToManyAccess.setRelInfo(
              object.reports,
              store,
              RelInfo<Report>.toOneBacklink(5, object.id,
                  (Report srcObject) => srcObject.shortUserRelationReport),
              store.box<ShortUser>());
          return object;
        }),
    TypeModel: EntityDefinition<TypeModel>(
        model: _entities[7],
        toOneRelations: (TypeModel object) => [],
        toManyRelations: (TypeModel object) => {
              RelInfo<Report>.toOneBacklink(4, object.id,
                      (Report srcObject) => srcObject.typeModelRelation):
                  object.reports
            },
        getId: (TypeModel object) => object.id,
        setId: (TypeModel object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field TypeModel.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (TypeModel object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          fbb.startTable(3);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, nameOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = TypeModel(
              id: const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0),
              name: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 6, ''));
          InternalToManyAccess.setRelInfo(
              object.reports,
              store,
              RelInfo<Report>.toOneBacklink(4, object.id,
                  (Report srcObject) => srcObject.typeModelRelation),
              store.box<TypeModel>());
          return object;
        }),
    User: EntityDefinition<User>(
        model: _entities[8],
        toOneRelations: (User object) => [object.permissionRelation],
        toManyRelations: (User object) => {},
        getId: (User object) => object.id,
        setId: (User object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field User.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (User object, fb.Builder fbb) {
          final imageUrlOffset = fbb.writeString(object.imageUrl);
          final nameOffset = fbb.writeString(object.name);
          final phoneOffset = fbb.writeString(object.phone);
          final refreshTokenOffset = fbb.writeString(object.refreshToken);
          final accessTokenOffset = fbb.writeString(object.accessToken);
          fbb.startTable(10);
          fbb.addOffset(0, imageUrlOffset);
          fbb.addOffset(1, nameOffset);
          fbb.addOffset(2, phoneOffset);
          fbb.addOffset(3, refreshTokenOffset);
          fbb.addBool(4, object.isOtherUser);
          fbb.addOffset(5, accessTokenOffset);
          fbb.addInt64(6, object.accessTokenExpiryDate.millisecondsSinceEpoch);
          fbb.addInt64(7, object.id);
          fbb.addInt64(8, object.permissionRelation.targetId);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = User(
              id: const fb.Int64Reader().vTableGet(buffer, rootOffset, 18, 0),
              name: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 6, ''),
              imageUrl: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 4, ''),
              phone: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 8, ''),
              refreshToken: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 10, ''),
              accessTokenExpiryDate: DateTime.fromMillisecondsSinceEpoch(
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 16, 0)),
              accessToken: const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 14, ''),
              isOtherUser: const fb.BoolReader()
                  .vTableGet(buffer, rootOffset, 12, false));
          object.permissionRelation.targetId =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 20, 0);
          object.permissionRelation.attach(store);
          return object;
        })
  };

  return ModelDefinition(model, bindings);
}

/// [PermissionModel] entity fields to define ObjectBox queries.
class PermissionModel_ {
  /// see [PermissionModel.id]
  static final id =
      QueryIntegerProperty<PermissionModel>(_entities[0].properties[0]);

  /// see [PermissionModel.name]
  static final name =
      QueryStringProperty<PermissionModel>(_entities[0].properties[1]);
}

/// [PriorityModel] entity fields to define ObjectBox queries.
class PriorityModel_ {
  /// see [PriorityModel.id]
  static final id =
      QueryIntegerProperty<PriorityModel>(_entities[1].properties[0]);

  /// see [PriorityModel.color]
  static final color =
      QueryStringProperty<PriorityModel>(_entities[1].properties[1]);
}

/// [RegionModel] entity fields to define ObjectBox queries.
class RegionModel_ {
  /// see [RegionModel.id]
  static final id =
      QueryIntegerProperty<RegionModel>(_entities[2].properties[0]);

  /// see [RegionModel.name]
  static final name =
      QueryStringProperty<RegionModel>(_entities[2].properties[1]);

  /// see [RegionModel.users]
  static final users =
      QueryRelationToMany<RegionModel, User>(_entities[2].relations[0]);
}

/// [Report] entity fields to define ObjectBox queries.
class Report_ {
  /// see [Report.patientIsCame]
  static final patientIsCame =
      QueryBooleanProperty<Report>(_entities[3].properties[0]);

  /// see [Report.priorityModelRelation]
  static final priorityModelRelation =
      QueryRelationToOne<Report, PriorityModel>(_entities[3].properties[1]);

  /// see [Report.regionModelRelation]
  static final regionModelRelation =
      QueryRelationToOne<Report, RegionModel>(_entities[3].properties[2]);

  /// see [Report.typeModelRelation]
  static final typeModelRelation =
      QueryRelationToOne<Report, TypeModel>(_entities[3].properties[3]);

  /// see [Report.shortUserRelationReport]
  static final shortUserRelationReport =
      QueryRelationToOne<Report, ShortUser>(_entities[3].properties[4]);

  /// see [Report.userIsReceived]
  static final userIsReceived =
      QueryBooleanProperty<Report>(_entities[3].properties[5]);

  /// see [Report.checkDate]
  static final checkDate =
      QueryIntegerProperty<Report>(_entities[3].properties[6]);

  /// see [Report.createdAt]
  static final createdAt =
      QueryIntegerProperty<Report>(_entities[3].properties[7]);

  /// see [Report.id]
  static final id = QueryIntegerProperty<Report>(_entities[3].properties[8]);

  /// see [Report.name]
  static final name = QueryStringProperty<Report>(_entities[3].properties[9]);

  /// see [Report.phone]
  static final phone = QueryStringProperty<Report>(_entities[3].properties[10]);

  /// see [Report.optionalPhone]
  static final optionalPhone =
      QueryStringProperty<Report>(_entities[3].properties[11]);

  /// see [Report.details]
  static final details =
      QueryStringProperty<Report>(_entities[3].properties[12]);

  /// see [Report.isSelected]
  static final isSelected =
      QueryBooleanProperty<Report>(_entities[3].properties[13]);

  /// see [Report.updatedAt]
  static final updatedAt =
      QueryIntegerProperty<Report>(_entities[3].properties[14]);

  /// see [Report.visitDate]
  static final visitDate =
      QueryIntegerProperty<Report>(_entities[3].properties[15]);

  /// see [Report.addressDetails]
  static final addressDetails =
      QueryStringProperty<Report>(_entities[3].properties[16]);
}

/// [ReportLog] entity fields to define ObjectBox queries.
class ReportLog_ {
  /// see [ReportLog.resultModelRelation]
  static final resultModelRelation =
      QueryRelationToOne<ReportLog, ResultModel>(_entities[4].properties[0]);

  /// see [ReportLog.shortUserRelationReportLog]
  static final shortUserRelationReportLog =
      QueryRelationToOne<ReportLog, ShortUser>(_entities[4].properties[1]);

  /// see [ReportLog.report]
  static final report =
      QueryRelationToOne<ReportLog, Report>(_entities[4].properties[2]);

  /// see [ReportLog.date]
  static final date =
      QueryIntegerProperty<ReportLog>(_entities[4].properties[3]);

  /// see [ReportLog.details]
  static final details =
      QueryStringProperty<ReportLog>(_entities[4].properties[4]);

  /// see [ReportLog.id]
  static final id = QueryIntegerProperty<ReportLog>(_entities[4].properties[5]);

  /// see [ReportLog.isSelected]
  static final isSelected =
      QueryBooleanProperty<ReportLog>(_entities[4].properties[6]);

  /// see [ReportLog.note]
  static final note =
      QueryStringProperty<ReportLog>(_entities[4].properties[7]);
}

/// [ResultModel] entity fields to define ObjectBox queries.
class ResultModel_ {
  /// see [ResultModel.id]
  static final id =
      QueryIntegerProperty<ResultModel>(_entities[5].properties[0]);

  /// see [ResultModel.name]
  static final name =
      QueryStringProperty<ResultModel>(_entities[5].properties[1]);

  /// see [ResultModel.type]
  static final type =
      QueryStringProperty<ResultModel>(_entities[5].properties[2]);
}

/// [ShortUser] entity fields to define ObjectBox queries.
class ShortUser_ {
  /// see [ShortUser.name]
  static final name =
      QueryStringProperty<ShortUser>(_entities[6].properties[0]);

  /// see [ShortUser.id]
  static final id = QueryIntegerProperty<ShortUser>(_entities[6].properties[1]);
}

/// [TypeModel] entity fields to define ObjectBox queries.
class TypeModel_ {
  /// see [TypeModel.id]
  static final id = QueryIntegerProperty<TypeModel>(_entities[7].properties[0]);

  /// see [TypeModel.name]
  static final name =
      QueryStringProperty<TypeModel>(_entities[7].properties[1]);
}

/// [User] entity fields to define ObjectBox queries.
class User_ {
  /// see [User.imageUrl]
  static final imageUrl = QueryStringProperty<User>(_entities[8].properties[0]);

  /// see [User.name]
  static final name = QueryStringProperty<User>(_entities[8].properties[1]);

  /// see [User.phone]
  static final phone = QueryStringProperty<User>(_entities[8].properties[2]);

  /// see [User.refreshToken]
  static final refreshToken =
      QueryStringProperty<User>(_entities[8].properties[3]);

  /// see [User.isOtherUser]
  static final isOtherUser =
      QueryBooleanProperty<User>(_entities[8].properties[4]);

  /// see [User.accessToken]
  static final accessToken =
      QueryStringProperty<User>(_entities[8].properties[5]);

  /// see [User.accessTokenExpiryDate]
  static final accessTokenExpiryDate =
      QueryIntegerProperty<User>(_entities[8].properties[6]);

  /// see [User.id]
  static final id = QueryIntegerProperty<User>(_entities[8].properties[7]);

  /// see [User.permissionRelation]
  static final permissionRelation =
      QueryRelationToOne<User, PermissionModel>(_entities[8].properties[8]);
}
